#define MPU6050_DMP_CODE_SIZE         1929    // the number of values for writing the dmpMemory[]
#define MPU6050_DMP_CONFIG_SIZE        192    // the number of values for writing the dmpConfig[]
#define MPU6050_DMP_UPDATES_SIZE        47    // the number of values for writing the dmpUpdates[]



// This array contains the default DMP memory bank binary that gets loaded during dmpInitialize().
// It was reconstructed from observed I2C traffic generated by the UC3-A3 demo code, and not extracted
// directly from that code. That is true of all transmissions in this sketch, and any documentation has
// been added after the fact by referencing the Invensense code.
// It gets written to volatile memory, so it has to be done at each start (it only takes ~1 second though).
const unsigned char dmpMemory[MPU6050_DMP_CODE_SIZE] PROGMEM = {
    // bank 0, 256 bytes
    0xFB, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x36, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
    0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0xFA, 0x80, 0x00, 0x0B, 0x12, 0x82, 0x00, 0x01,
    0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x28, 0x00, 0x00, 0xFF, 0xFF, 0x45, 0x81, 0xFF, 0xFF, 0xFA, 0x72, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFE, 0x80, 0x01,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x3E, 0x03, 0x30, 0x40, 0x00, 0x00, 0x00, 0x02, 0xCA, 0xE3, 0x09, 0x3E, 0x80, 0x00, 0x00,
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0x41, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x2A, 0x00, 0x00, 0x16, 0x55, 0x00, 0x00, 0x21, 0x82,
    0xFD, 0x87, 0x26, 0x50, 0xFD, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6F, 0x00, 0x02, 0x65, 0x32, 0x00, 0x00, 0x5E, 0xC0,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFB, 0x8C, 0x6F, 0x5D, 0xFD, 0x5D, 0x08, 0xD9, 0x00, 0x7C, 0x73, 0x3B, 0x00, 0x6C, 0x12, 0xCC,
    0x32, 0x00, 0x13, 0x9D, 0x32, 0x00, 0xD0, 0xD6, 0x32, 0x00, 0x08, 0x00, 0x40, 0x00, 0x01, 0xF4,
    0xFF, 0xE6, 0x80, 0x79, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xD6, 0x00, 0x00, 0x27, 0x10,

    // bank 1, 256 bytes
    0xFB, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFA, 0x36, 0xFF, 0xBC, 0x30, 0x8E, 0x00, 0x05, 0xFB, 0xF0, 0xFF, 0xD9, 0x5B, 0xC8,
    0xFF, 0xD0, 0x9A, 0xBE, 0x00, 0x00, 0x10, 0xA9, 0xFF, 0xF4, 0x1E, 0xB2, 0x00, 0xCE, 0xBB, 0xF7,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0C,
    0xFF, 0xC2, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xCF, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x68, 0xB6, 0x79, 0x35, 0x28, 0xBC, 0xC6, 0x7E, 0xD1, 0x6C,
    0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x6A, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x30,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x25, 0x4D, 0x00, 0x2F, 0x70, 0x6D, 0x00, 0x00, 0x05, 0xAE, 0x00, 0x0C, 0x02, 0xD0,

    // bank 2, 256 bytes
    0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0xFF, 0xEF, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    // bank 3, 256 bytes
    0xD8, 0xDC, 0xBA, 0xA2, 0xF1, 0xDE, 0xB2, 0xB8, 0xB4, 0xA8, 0x81, 0x91, 0xF7, 0x4A, 0x90, 0x7F,
    0x91, 0x6A, 0xF3, 0xF9, 0xDB, 0xA8, 0xF9, 0xB0, 0xBA, 0xA0, 0x80, 0xF2, 0xCE, 0x81, 0xF3, 0xC2,
    0xF1, 0xC1, 0xF2, 0xC3, 0xF3, 0xCC, 0xA2, 0xB2, 0x80, 0xF1, 0xC6, 0xD8, 0x80, 0xBA, 0xA7, 0xDF,
    0xDF, 0xDF, 0xF2, 0xA7, 0xC3, 0xCB, 0xC5, 0xB6, 0xF0, 0x87, 0xA2, 0x94, 0x24, 0x48, 0x70, 0x3C,
    0x95, 0x40, 0x68, 0x34, 0x58, 0x9B, 0x78, 0xA2, 0xF1, 0x83, 0x92, 0x2D, 0x55, 0x7D, 0xD8, 0xB1,
    0xB4, 0xB8, 0xA1, 0xD0, 0x91, 0x80, 0xF2, 0x70, 0xF3, 0x70, 0xF2, 0x7C, 0x80, 0xA8, 0xF1, 0x01,
    0xB0, 0x98, 0x87, 0xD9, 0x43, 0xD8, 0x86, 0xC9, 0x88, 0xBA, 0xA1, 0xF2, 0x0E, 0xB8, 0x97, 0x80,
    0xF1, 0xA9, 0xDF, 0xDF, 0xDF, 0xAA, 0xDF, 0xDF, 0xDF, 0xF2, 0xAA, 0xC5, 0xCD, 0xC7, 0xA9, 0x0C,
    0xC9, 0x2C, 0x97, 0x97, 0x97, 0x97, 0xF1, 0xA9, 0x89, 0x26, 0x46, 0x66, 0xB0, 0xB4, 0xBA, 0x80,
    0xAC, 0xDE, 0xF2, 0xCA, 0xF1, 0xB2, 0x8C, 0x02, 0xA9, 0xB6, 0x98, 0x00, 0x89, 0x0E, 0x16, 0x1E,
    0xB8, 0xA9, 0xB4, 0x99, 0x2C, 0x54, 0x7C, 0xB0, 0x8A, 0xA8, 0x96, 0x36, 0x56, 0x76, 0xF1, 0xB9,
    0xAF, 0xB4, 0xB0, 0x83, 0xC0, 0xB8, 0xA8, 0x97, 0x11, 0xB1, 0x8F, 0x98, 0xB9, 0xAF, 0xF0, 0x24,
    0x08, 0x44, 0x10, 0x64, 0x18, 0xF1, 0xA3, 0x29, 0x55, 0x7D, 0xAF, 0x83, 0xB5, 0x93, 0xAF, 0xF0,
    0x00, 0x28, 0x50, 0xF1, 0xA3, 0x86, 0x9F, 0x61, 0xA6, 0xDA, 0xDE, 0xDF, 0xD9, 0xFA, 0xA3, 0x86,
    0x96, 0xDB, 0x31, 0xA6, 0xD9, 0xF8, 0xDF, 0xBA, 0xA6, 0x8F, 0xC2, 0xC5, 0xC7, 0xB2, 0x8C, 0xC1,
    0xB8, 0xA2, 0xDF, 0xDF, 0xDF, 0xA3, 0xDF, 0xDF, 0xDF, 0xD8, 0xD8, 0xF1, 0xB8, 0xA8, 0xB2, 0x86,

    // bank 4, 256 bytes
    0xB4, 0x98, 0x0D, 0x35, 0x5D, 0xB8, 0xAA, 0x98, 0xB0, 0x87, 0x2D, 0x35, 0x3D, 0xB2, 0xB6, 0xBA,
    0xAF, 0x8C, 0x96, 0x19, 0x8F, 0x9F, 0xA7, 0x0E, 0x16, 0x1E, 0xB4, 0x9A, 0xB8, 0xAA, 0x87, 0x2C,
    0x54, 0x7C, 0xB9, 0xA3, 0xDE, 0xDF, 0xDF, 0xA3, 0xB1, 0x80, 0xF2, 0xC4, 0xCD, 0xC9, 0xF1, 0xB8,
    0xA9, 0xB4, 0x99, 0x83, 0x0D, 0x35, 0x5D, 0x89, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0xB5, 0x93, 0xA3,
    0x0E, 0x16, 0x1E, 0xA9, 0x2C, 0x54, 0x7C, 0xB8, 0xB4, 0xB0, 0xF1, 0x97, 0x83, 0xA8, 0x11, 0x84,
    0xA5, 0x09, 0x98, 0xA3, 0x83, 0xF0, 0xDA, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xD8, 0xF1, 0xA5,
    0x29, 0x55, 0x7D, 0xA5, 0x85, 0x95, 0x02, 0x1A, 0x2E, 0x3A, 0x56, 0x5A, 0x40, 0x48, 0xF9, 0xF3,
    0xA3, 0xD9, 0xF8, 0xF0, 0x98, 0x83, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0x97, 0x82, 0xA8, 0xF1,
    0x11, 0xF0, 0x98, 0xA2, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xDA, 0xF3, 0xDE, 0xD8, 0x83, 0xA5,
    0x94, 0x01, 0xD9, 0xA3, 0x02, 0xF1, 0xA2, 0xC3, 0xC5, 0xC7, 0xD8, 0xF1, 0x84, 0x92, 0xA2, 0x4D,
    0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
    0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0x93, 0xA3, 0x4D,
    0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
    0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0xA8, 0x8A, 0x9A,
    0xF0, 0x28, 0x50, 0x78, 0x9E, 0xF3, 0x88, 0x18, 0xF1, 0x9F, 0x1D, 0x98, 0xA8, 0xD9, 0x08, 0xD8,
    0xC8, 0x9F, 0x12, 0x9E, 0xF3, 0x15, 0xA8, 0xDA, 0x12, 0x10, 0xD8, 0xF1, 0xAF, 0xC8, 0x97, 0x87,

    // bank 5, 256 bytes
    0x34, 0xB5, 0xB9, 0x94, 0xA4, 0x21, 0xF3, 0xD9, 0x22, 0xD8, 0xF2, 0x2D, 0xF3, 0xD9, 0x2A, 0xD8,
    0xF2, 0x35, 0xF3, 0xD9, 0x32, 0xD8, 0x81, 0xA4, 0x60, 0x60, 0x61, 0xD9, 0x61, 0xD8, 0x6C, 0x68,
    0x69, 0xD9, 0x69, 0xD8, 0x74, 0x70, 0x71, 0xD9, 0x71, 0xD8, 0xB1, 0xA3, 0x84, 0x19, 0x3D, 0x5D,
    0xA3, 0x83, 0x1A, 0x3E, 0x5E, 0x93, 0x10, 0x30, 0x81, 0x10, 0x11, 0xB8, 0xB0, 0xAF, 0x8F, 0x94,
    0xF2, 0xDA, 0x3E, 0xD8, 0xB4, 0x9A, 0xA8, 0x87, 0x29, 0xDA, 0xF8, 0xD8, 0x87, 0x9A, 0x35, 0xDA,
    0xF8, 0xD8, 0x87, 0x9A, 0x3D, 0xDA, 0xF8, 0xD8, 0xB1, 0xB9, 0xA4, 0x98, 0x85, 0x02, 0x2E, 0x56,
    0xA5, 0x81, 0x00, 0x0C, 0x14, 0xA3, 0x97, 0xB0, 0x8A, 0xF1, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9,
    0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x84, 0x0D, 0xDA, 0x0E, 0xD8, 0xA3, 0x29, 0x83, 0xDA,
    0x2C, 0x0E, 0xD8, 0xA3, 0x84, 0x49, 0x83, 0xDA, 0x2C, 0x4C, 0x0E, 0xD8, 0xB8, 0xB0, 0xA8, 0x8A,
    0x9A, 0xF5, 0x20, 0xAA, 0xDA, 0xDF, 0xD8, 0xA8, 0x40, 0xAA, 0xD0, 0xDA, 0xDE, 0xD8, 0xA8, 0x60,
    0xAA, 0xDA, 0xD0, 0xDF, 0xD8, 0xF1, 0x97, 0x86, 0xA8, 0x31, 0x9B, 0x06, 0x99, 0x07, 0xAB, 0x97,
    0x28, 0x88, 0x9B, 0xF0, 0x0C, 0x20, 0x14, 0x40, 0xB8, 0xB0, 0xB4, 0xA8, 0x8C, 0x9C, 0xF0, 0x04,
    0x28, 0x51, 0x79, 0x1D, 0x30, 0x14, 0x38, 0xB2, 0x82, 0xAB, 0xD0, 0x98, 0x2C, 0x50, 0x50, 0x78,
    0x78, 0x9B, 0xF1, 0x1A, 0xB0, 0xF0, 0x8A, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x8B, 0x29, 0x51, 0x79,
    0x8A, 0x24, 0x70, 0x59, 0x8B, 0x20, 0x58, 0x71, 0x8A, 0x44, 0x69, 0x38, 0x8B, 0x39, 0x40, 0x68,
    0x8A, 0x64, 0x48, 0x31, 0x8B, 0x30, 0x49, 0x60, 0xA5, 0x88, 0x20, 0x09, 0x71, 0x58, 0x44, 0x68,

    // bank 6, 256 bytes
    0x11, 0x39, 0x64, 0x49, 0x30, 0x19, 0xF1, 0xAC, 0x00, 0x2C, 0x54, 0x7C, 0xF0, 0x8C, 0xA8, 0x04,
    0x28, 0x50, 0x78, 0xF1, 0x88, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xAC, 0x8C, 0x02, 0x26, 0x46, 0x66,
    0xF0, 0x89, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31,
    0xA9, 0x88, 0x09, 0x20, 0x59, 0x70, 0xAB, 0x11, 0x38, 0x40, 0x69, 0xA8, 0x19, 0x31, 0x48, 0x60,
    0x8C, 0xA8, 0x3C, 0x41, 0x5C, 0x20, 0x7C, 0x00, 0xF1, 0x87, 0x98, 0x19, 0x86, 0xA8, 0x6E, 0x76,
    0x7E, 0xA9, 0x99, 0x88, 0x2D, 0x55, 0x7D, 0x9E, 0xB9, 0xA3, 0x8A, 0x22, 0x8A, 0x6E, 0x8A, 0x56,
    0x8A, 0x5E, 0x9F, 0xB1, 0x83, 0x06, 0x26, 0x46, 0x66, 0x0E, 0x2E, 0x4E, 0x6E, 0x9D, 0xB8, 0xAD,
    0x00, 0x2C, 0x54, 0x7C, 0xF2, 0xB1, 0x8C, 0xB4, 0x99, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0x81, 0x91,
    0xAC, 0x38, 0xAD, 0x3A, 0xB5, 0x83, 0x91, 0xAC, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9, 0x48, 0xD8,
    0x6D, 0xD9, 0x68, 0xD8, 0x8C, 0x9D, 0xAE, 0x29, 0xD9, 0x04, 0xAE, 0xD8, 0x51, 0xD9, 0x04, 0xAE,
    0xD8, 0x79, 0xD9, 0x04, 0xD8, 0x81, 0xF3, 0x9D, 0xAD, 0x00, 0x8D, 0xAE, 0x19, 0x81, 0xAD, 0xD9,
    0x01, 0xD8, 0xF2, 0xAE, 0xDA, 0x26, 0xD8, 0x8E, 0x91, 0x29, 0x83, 0xA7, 0xD9, 0xAD, 0xAD, 0xAD,
    0xAD, 0xF3, 0x2A, 0xD8, 0xD8, 0xF1, 0xB0, 0xAC, 0x89, 0x91, 0x3E, 0x5E, 0x76, 0xF3, 0xAC, 0x2E,
    0x2E, 0xF1, 0xB1, 0x8C, 0x5A, 0x9C, 0xAC, 0x2C, 0x28, 0x28, 0x28, 0x9C, 0xAC, 0x30, 0x18, 0xA8,
    0x98, 0x81, 0x28, 0x34, 0x3C, 0x97, 0x24, 0xA7, 0x28, 0x34, 0x3C, 0x9C, 0x24, 0xF2, 0xB0, 0x89,
    0xAC, 0x91, 0x2C, 0x4C, 0x6C, 0x8A, 0x9B, 0x2D, 0xD9, 0xD8, 0xD8, 0x51, 0xD9, 0xD8, 0xD8, 0x79,

    // bank 7, 137 bytes (remainder)
    0xD9, 0xD8, 0xD8, 0xF1, 0x9E, 0x88, 0xA3, 0x31, 0xDA, 0xD8, 0xD8, 0x91, 0x2D, 0xD9, 0x28, 0xD8,
    0x4D, 0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x83, 0x93, 0x35, 0x3D, 0x80, 0x25, 0xDA,
    0xD8, 0xD8, 0x85, 0x69, 0xDA, 0xD8, 0xD8, 0xB4, 0x93, 0x81, 0xA3, 0x28, 0x34, 0x3C, 0xF3, 0xAB,
    0x8B, 0xF8, 0xA3, 0x91, 0xB6, 0x09, 0xB4, 0xD9, 0xAB, 0xDE, 0xFA, 0xB0, 0x87, 0x9C, 0xB9, 0xA3,
    0xDD, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x95, 0xF1, 0xA3, 0xA3, 0xA3, 0x9D, 0xF1, 0xA3, 0xA3, 0xA3,
    0xA3, 0xF2, 0xA3, 0xB4, 0x90, 0x80, 0xF2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
    0xA3, 0xB2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xB0, 0x87, 0xB5, 0x99, 0xF1, 0xA3, 0xA3, 0xA3,
    0x98, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x97, 0xA3, 0xA3, 0xA3, 0xA3, 0xF3, 0x9B, 0xA3, 0xA3, 0xDC,
    0xB9, 0xA7, 0xF1, 0x26, 0x26, 0x26, 0xD8, 0xD8, 0xFF
};

// This array contains the DMP configurations that gets loaded during dmpInitialize().
// thanks to Noah Zerkin for piecing this stuff together!
const unsigned char dmpConfig[MPU6050_DMP_CONFIG_SIZE] PROGMEM = {
//  BANK    OFFSET  LENGTH  [DATA]
    0x03,   0x7B,   0x03,   0x4C, 0xCD, 0x6C,                   // FCFG_1 inv_set_gyro_calibration
    0x03,   0xAB,   0x03,   0x36, 0x56, 0x76,                   // FCFG_3 inv_set_gyro_calibration
    0x00,   0x68,   0x04,   0x02, 0xCB, 0x47, 0xA2,             // D_0_104 inv_set_gyro_calibration
    0x02,   0x18,   0x04,   0x00, 0x05, 0x8B, 0xC1,             // D_0_24 inv_set_gyro_calibration
    0x01,   0x0C,   0x04,   0x00, 0x00, 0x00, 0x00,             // D_1_152 inv_set_accel_calibration
    0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97, // FCFG_2 inv_set_accel_calibration
    0x03,   0x89,   0x03,   0x26, 0x46, 0x66,                   // FCFG_7 inv_set_accel_calibration
    0x00,   0x6C,   0x02,   0x20, 0x00,                         // D_0_108 inv_set_accel_calibration
    0x02,   0x40,   0x04,   0x00, 0x00, 0x00, 0x00,             // CPASS_MTX_00 inv_set_compass_calibration
    0x02,   0x44,   0x04,   0x00, 0x00, 0x00, 0x00,             // CPASS_MTX_01
    0x02,   0x48,   0x04,   0x00, 0x00, 0x00, 0x00,             // CPASS_MTX_02
    0x02,   0x4C,   0x04,   0x00, 0x00, 0x00, 0x00,             // CPASS_MTX_10
    0x02,   0x50,   0x04,   0x00, 0x00, 0x00, 0x00,             // CPASS_MTX_11
    0x02,   0x54,   0x04,   0x00, 0x00, 0x00, 0x00,             // CPASS_MTX_12
    0x02,   0x58,   0x04,   0x00, 0x00, 0x00, 0x00,             // CPASS_MTX_20
    0x02,   0x5C,   0x04,   0x00, 0x00, 0x00, 0x00,             // CPASS_MTX_21
    0x02,   0xBC,   0x04,   0x00, 0x00, 0x00, 0x00,             // CPASS_MTX_22
    0x01,   0xEC,   0x04,   0x00, 0x00, 0x40, 0x00,             // D_1_236 inv_apply_endian_accel
    0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97, // FCFG_2 inv_set_mpu_sensors
    0x04,   0x02,   0x03,   0x0D, 0x35, 0x5D,                   // CFG_MOTION_BIAS inv_turn_on_bias_from_no_motion
    0x04,   0x09,   0x04,   0x87, 0x2D, 0x35, 0x3D,             // FCFG_5 inv_set_bias_update
    0x00,   0xA3,   0x01,   0x00,                               // D_0_163 inv_set_dead_zone
                 // SPECIAL 0x01 = enable interrupts
    0x00,   0x00,   0x00,   0x01, // SET INT_ENABLE at i=22, SPECIAL INSTRUCTION
    0x07,   0x86,   0x01,   0xFE,                               // CFG_6 inv_set_fifo_interupt
    0x07,   0x41,   0x05,   0xF1, 0x20, 0x28, 0x30, 0x38,       // CFG_8 inv_send_quaternion
    0x07,   0x7E,   0x01,   0x30,                               // CFG_16 inv_set_footer
    0x07,   0x46,   0x01,   0x9A,                               // CFG_GYRO_SOURCE inv_send_gyro
    0x07,   0x47,   0x04,   0xF1, 0x28, 0x30, 0x38,             // CFG_9 inv_send_gyro -> inv_construct3_fifo
    0x07,   0x6C,   0x04,   0xF1, 0x28, 0x30, 0x38,             // CFG_12 inv_send_accel -> inv_construct3_fifo
    0x02,   0x16,   0x02,   0x00, 0x01                          // D_0_22 inv_set_fifo_rate

    // This very last 0x01 WAS a 0x09, which drops the FIFO rate down to 20 Hz. 0x07 is 25 Hz,
    // 0x01 is 100 Hz. Going faster than 100 Hz (0x00 = 200 Hz) tends to result in very noisy data.
    // DMP output frequency is calculated easily using this equation: (200 Hz / (1 + value)).

    // It is important to make sure the host processor can keep up with reading and processing
    // the FIFO output at the desired rate. Handling FIFO overflow cleanly is also a good idea.
};

// This array contains the DMP updates that get loaded during dmpInitialize().
const unsigned char dmpUpdates[MPU6050_DMP_UPDATES_SIZE] PROGMEM = {
    0x01,   0xB2,   0x02,   0xFF, 0xFF,
    0x01,   0x90,   0x04,   0x09, 0x23, 0xA1, 0x35,
    0x01,   0x6A,   0x02,   0x06, 0x00,
    0x01,   0x60,   0x08,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00,   0x60,   0x04,   0x40, 0x00, 0x00, 0x00,
    0x01,   0x62,   0x02,   0x00, 0x00,
    0x00,   0x60,   0x04,   0x00, 0x40, 0x00, 0x00
};









// ############################################################################################## //
// ################################ DMP functions used in dmpInitialize() ####################### //
// ############################################################################################## //
// If you like to know how it works, please read on. Otherwise, just FIRE AND FORGET ;-)

void setMemoryBank(byte bank, boolean prefetchEnabled, boolean userBank, int ChipSelPin)
{
  // - the value in 0x6D activates a specific bank in the DMP
  // - the value in 0x6E sets the read/write pointer to a specific startaddress within the specified DMP bank
  // - register 0x6F is the register from which to read or to which to write the data
  //   (after each r/w autoincrement address within the specified DMP bank starting from startaddress)
  bank = bank & 0x1F; // 0x1F = 00011111
  // bank 0: 0 & 0x1F = 00000000 $ 00011111 = 00000000
  // bank 1: 1 & 0x1F = 00000001 $ 00011111 = 00000001
  // bank 2: 2 & 0x1F = 00000010 $ 00011111 = 00000010
  // bank 3: 3 & 0x1F = 00000011 $ 00011111 = 00000011
  // bank 4: 4 & 0x1F = 00000100 $ 00011111 = 00000100
  // bank 5: 5 & 0x1F = 00000101 $ 00011111 = 00000101
  // bank 6: 6 & 0x1F = 00000110 $ 00011111 = 00000110
  // bank 7: 7 & 0x1F = 00000111 $ 00011111 = 00000111
  // is this to maximize the number of banks to 00011111 is 0x1F = 31 ?
  if (userBank) bank |= 0x20;
  if (prefetchEnabled) bank |= 0x40;
  SPIwrite(0x6D, bank, ChipSelPin);
}

//***********************************************************//
void setMemoryStartAddress(byte startaddress, int ChipSelPin)
{
  // - the value in 0x6D activates a specific bank in the DMP
  // - the value in 0x6E sets the read/write pointer to a specific startaddress within the specified DMP bank
  // - register 0x6F is the register from which to read or to which to write the data
  //   (after each r/w autoincrement address within the specified DMP bank starting from startaddress)
  SPIwrite(0x6E, startaddress, ChipSelPin);
}


//***********************************************************//
boolean writeDMPMemory()
{
  // - the value in 0x6D activates a specific bank in the DMP
  // - the value in 0x6E sets the read/write pointer to a specific startaddress within the specified DMP bank
  // - register 0x6F is the register from which to read or to which to write the data
  //   (after each r/w autoincrement address within the specified DMP bank starting from startaddress)

  Serial.print("\tWriting   DMP memory.......... ");
  
  unsigned int i, j;
  byte dmp_byte;

  // ### there are 8 DMP banks (numbers 0 to 7)
  
  // DMP banks 0 - 6 are completely filled with 256 bytes:
  for (i = 0; i < 7; i ++)
  {
    setMemoryBank(i, false, false, ChipSelPin1); // bank number  = i
    setMemoryStartAddress(0, ChipSelPin1);       // startaddress = 0 so start writing every DMP bank from the beginning
    digitalWrite(ChipSelPin1,LOW);
    SPI.transfer(0x6F);

    for (j = 0; j < 256; j ++) // max. 256 bytes of data fit into one DMP bank
    {
      dmp_byte = pgm_read_byte(dmpMemory + (i * 256) + j);
      SPI.transfer(dmp_byte);
      #ifdef DEBUG
        if (dmp_byte < 0x10) Serial.print("0"); // add leading zero - this is an Arduino bug
        Serial.println(dmp_byte, HEX);
      #endif
    }
    digitalWrite(ChipSelPin1,HIGH);
  }

  // DMP bank 7 gets only 137 bytes:
  setMemoryBank(7, false, false, ChipSelPin1); // bank number  = 7
  setMemoryStartAddress(0, ChipSelPin1);       // startaddress = 0 so start writing also this DMP bank from the beginning
  digitalWrite(ChipSelPin1,LOW);
  SPI.transfer(0x6F);

  for (j = 0; j < 137; j ++) // only 137 bytes of data into DMP bank 7
  {
    dmp_byte = pgm_read_byte(dmpMemory + (7 * 256) + j);
    SPI.transfer(dmp_byte);
    #ifdef DEBUG
      if (dmp_byte < 0x10) Serial.print("0"); // add leading zero - this is an Arduino bug
      Serial.println(dmp_byte, HEX);
    #endif
  }
  digitalWrite(ChipSelPin1,HIGH);

  Serial.println("done.");
  
  return true; // end of writeDMPMemory reached
}

//***********************************************************//
boolean verifyDMPMemory()
{
  // - the value in 0x6D activates a specific bank in the DMP
  // - the value in 0x6E sets the read/write pointer to a specific startaddress within the specified DMP bank
  // - register 0x6F is the register from which to read or to which to write the data
  //   (after each r/w autoincrement address within the specified DMP bank starting from startaddress)

  Serial.print("\tVerifying DMP memory.......... ");

  unsigned int i, j;
  byte dmp_byte, check_byte;
  boolean verification = true;
  
  // ### there are 8 DMP banks (numbers 0 to 7)
  
  // DMP banks 0 - 6 are completely read, all 256 bytes:
  for (i = 0; i < 7; i ++)
  {
    setMemoryBank(i, false, false, ChipSelPin1); // bank number  = i
    setMemoryStartAddress(0, ChipSelPin1);       // startaddress = 0 so start reading every DMP bank from the beginning
    digitalWrite(ChipSelPin1,LOW);
    SPI.transfer(0x6F | 0x80); // 0x6F | 0x80 causes a "1" added as MSB to 0x6F to denote reading from reg i.s.o. writing to it

    for (j = 0; j < 256; j ++) // max. 256 bytes of data fit into one DMP bank
    {
      check_byte = pgm_read_byte(dmpMemory + (i * 256) + j);
      dmp_byte = SPI.transfer(0x00);
      if (dmp_byte != check_byte)
      {
        Serial.println("$$$ dmpMemory: byte verification error");
        verification = false;
      }
      #ifdef DEBUG
        if (dmp_byte < 0x10) Serial.print("0"); // add leading zero - this is an Arduino bug
        Serial.println(dmp_byte, HEX);
      #endif
    }
    digitalWrite(ChipSelPin1,HIGH);
  }

  // DMP bank 7 only read first 137 bytes:
  setMemoryBank(7, false, false, ChipSelPin1); // bank number  = 7
  setMemoryStartAddress(0, ChipSelPin1);       // startaddress = 0 so start reading also this DMP bank from the beginning
  digitalWrite(ChipSelPin1,LOW);
  SPI.transfer(0x6F | 0x80); // 0x6F | 0x80 causes a "1" added as MSB to 0x6F to denote reading from reg i.s.o. writing to it

  for (j = 0; j < 137; j ++) // only 137 bytes of data into DMP bank 7
  {
    check_byte = pgm_read_byte(dmpMemory + (7 * 256) + j);
    dmp_byte = SPI.transfer(0x00);
    if (dmp_byte != check_byte)
    {
      Serial.println("$$$ dmpMemory: byte verification error");
      verification = false;
    }
    #ifdef DEBUG
      if (dmp_byte < 0x10) Serial.print("0"); // add leading zero - this is an Arduino bug
      Serial.println(dmp_byte, HEX);
    #endif
  }
  digitalWrite(ChipSelPin1,HIGH);
  
  if (verification == true)  Serial.println("success!");
  if (verification == false) Serial.println("FAILED!");

  return verification; // true if DMP correctly written, false if not
}

//***********************************************************//
boolean writeDMPConfig()
{
  byte progBuffer, success, special;
  unsigned int i, j;
  // config set dmpConfig is a long string of blocks with the following structure:
  // [bank] [offset] [length] [byte[0], byte[1], ..., byte[length]]
  byte bank, offset, length;

  Serial.print("\tWriting   DMP configuration... ");

  for (i = 0; i < MPU6050_DMP_CONFIG_SIZE;)
  {
    bank   = pgm_read_byte(dmpConfig + i++); // pgm_read_byte() is a macro that reads a byte of data stored in a specified address(PROGMEM area)
    offset = pgm_read_byte(dmpConfig + i++);
    length = pgm_read_byte(dmpConfig + i++);
    
    if (length > 0) // regular block of data to write
    {
      setMemoryBank(bank, false, false, ChipSelPin1); // bank number  = bank
      setMemoryStartAddress(offset, ChipSelPin1);     // startaddress = offset from the beginning (0) of the bank

      digitalWrite(ChipSelPin1,LOW);
      SPI.transfer(0x6F);

      for (j = 0; j < length; j++)
      {
        progBuffer = pgm_read_byte(dmpConfig + i + j);
        SPI.transfer(progBuffer);
      }
       
      digitalWrite(ChipSelPin1,HIGH);
      i = i + length;
    }
        
    else // length = 0; special instruction to write
    {
      // NOTE: this kind of behavior (what and when to do certain things)
      // is totally undocumented. This code is in here based on observed
      // behavior only, and exactly why (or even whether) it has to be here
      // is anybody's guess for now.
      special = pgm_read_byte(dmpConfig + i++);
      if (special == 0x01)
      {
        // enable DMP-related interrupts (ZeroMotion, FIFOBufferOverflow, DMP)
        SPIwrite(0x38, 0x32, ChipSelPin1);  // write 00110010: ZMOT_EN, FIFO_OFLOW_EN, DMP_INT_EN true
                                            // by the way: this sets all other interrupt enables to false
        success = true;
      }
      else
      {
        // unknown other special command if this may be needed in the future, but for now this should not happen
        success = false;
      }
    }
  }

  Serial.println("done.");

  return true;
}

//***********************************************************//
boolean verifyDMPConfig()
{
  byte check_byte, progBuffer, success, special;
  unsigned int i, j;
  // config set dmpConfig is a long string of blocks with the following structure:
  // [bank] [offset] [length] [byte[0], byte[1], ..., byte[length]]
  byte bank, offset, length;
  boolean verification = true;

  Serial.print("\tVerifying DMP configuration... ");

  for (i = 0; i < MPU6050_DMP_CONFIG_SIZE;)
  {
    bank   = pgm_read_byte(dmpConfig + i++); // pgm_read_byte() is a macro that reads a byte of data stored in a specified address(PROGMEM area)
    offset = pgm_read_byte(dmpConfig + i++);
    length = pgm_read_byte(dmpConfig + i++);
      
    if (length > 0) // regular block of data to read
    {
      setMemoryBank(bank, false, false, ChipSelPin1); // bank number  = bank
      setMemoryStartAddress(offset, ChipSelPin1);     // startaddress = offset from the beginning (0) of the bank

      digitalWrite(ChipSelPin1,LOW);
      SPI.transfer(0x6F | 0x80); // 0x6F | 0x80 causes a "1" added as MSB to 0x6F to denote reading from reg i.s.o. writing to it

      for (j = 0; j < length; j++)
      {
        progBuffer = pgm_read_byte(dmpConfig + i + j);
        check_byte = SPI.transfer(0x00);
        if (progBuffer != check_byte)
        {
          verification = false;
        }
        #ifdef DEBUG
          if (check_byte < 0x10) Serial.print("0"); // add leading zero - this is an Arduino bug
          Serial.println(check_byte, HEX);
        #endif
      }
       
      digitalWrite(ChipSelPin1,HIGH);
      i = i + length;
    }
        
    else // length = 0; special instruction to write
    {
      // NOTE: this kind of behavior (what and when to do certain things)
      // is totally undocumented. This code is in here based on observed
      // behavior only, and exactly why (or even whether) it has to be here
      // is anybody's guess for now.
      special = pgm_read_byte(dmpConfig + i++);
      if (special == 0x01)
      {
        // enable DMP-related interrupts (ZeroMotion, FIFOBufferOverflow, DMP)
        check_byte = SPIread(0x38, ChipSelPin1);  // shoudl read 00110010: ZMOT_EN, FIFO_OFLOW_EN, DMP_INT_EN true
                                                  
        if (check_byte != 0x32)
        {
          verification = false;
        }
        #ifdef DEBUG
          if (check_byte < 0x10) Serial.print("0"); // add leading zero - this is an Arduino bug
          Serial.println(check_byte, HEX);
        #endif

        success = true;
      }
      else
      {
        // unknown special command
        success = false;
      }
    }
  }

  if (verification == true)  Serial.println("success!");
  if (verification == false) Serial.println("FAILED!");

  return verification; // true if DMP correctly written, false if not
}

//***********************************************************//
unsigned int writeDMPUpdates(unsigned int pos, byte update_number)
// process only one line from dmpUpdates each time writeDMPUpdates() is called
{
  // pos is the current reading position within dmpUpdates
  byte progBuffer, success;
  unsigned int j;
  // config set dmpUpdates is a long string of blocks with the following structure:
  // [bank] [offset] [length] [byte[0], byte[1], ..., byte[length]]
  byte bank, offset, length;

  Serial.print("\tWriting   DMP update "); Serial.print(update_number); Serial.print("/7 ..... ");


  bank   = pgm_read_byte(dmpUpdates + pos++); // pgm_read_byte() is a macro that reads a byte of data stored in a specified address(PROGMEM area)
  offset = pgm_read_byte(dmpUpdates + pos++);
  length = pgm_read_byte(dmpUpdates + pos++);
      
  setMemoryBank(bank, false, false, ChipSelPin1); // bank number  = bank
  setMemoryStartAddress(offset, ChipSelPin1);     // startaddress = offset from the beginning (0) of the bank

  digitalWrite(ChipSelPin1,LOW);
  SPI.transfer(0x6F);

  for (j = 0; j < length; j++)
  {
    progBuffer = pgm_read_byte(dmpUpdates + pos + j);
    SPI.transfer(progBuffer);
  }
       
  digitalWrite(ChipSelPin1,HIGH);
  pos = pos + length;

  Serial.println("done.");

  return pos; // return last used position in dmpUpdates: will be starting point for next call!
}

//***********************************************************//
unsigned int verifyDMPUpdates(unsigned int pos_verify, byte update_number)
// process only one line from dmpUpdates each time writeDMPUpdates() is called
{
  // pos_verify is the current verifying position within dmpUpdates
  byte check_byte, progBuffer, success;
  unsigned int j;
  // config set dmpUpdates is a long string of blocks with the following structure:
  // [bank] [offset] [length] [byte[0], byte[1], ..., byte[length]]
  byte bank, offset, length;
  boolean verification = true;

  Serial.print("\tVerifying DMP update "); Serial.print(update_number); Serial.print("/7 ..... ");

  bank   = pgm_read_byte(dmpUpdates + pos_verify++); // pgm_read_byte() is a macro that reads a byte of data stored in a specified address(PROGMEM area)
  offset = pgm_read_byte(dmpUpdates + pos_verify++);
  length = pgm_read_byte(dmpUpdates + pos_verify++);
      
  setMemoryBank(bank, false, false, ChipSelPin1); // bank number  = bank
  setMemoryStartAddress(offset, ChipSelPin1);     // startaddress = offset from the beginning (0) of the bank

  digitalWrite(ChipSelPin1,LOW);
  SPI.transfer(0x6F | 0x80); // 0x6F | 0x80 causes a "1" added as MSB to 0x6F to denote reading from reg i.s.o. writing to it

  for (j = 0; j < length; j++)
  {
    progBuffer = pgm_read_byte(dmpUpdates + pos_verify + j);
    check_byte = SPI.transfer(0x00);
    if (progBuffer != check_byte)
    {
      verification = false;
    }
    #ifdef DEBUG
      if (check_byte < 0x10) Serial.print("0"); // add leading zero - this is an Arduino bug
      Serial.println(check_byte, HEX);
    #endif
  }
       
  digitalWrite(ChipSelPin1,HIGH);
  pos_verify = pos_verify + length;

  if (verification == true)  Serial.println("success!");
  if (verification == false) Serial.println("FAILED!");
  //return verification; // true if DMP correctly written, false if not

  return pos_verify; // return last used position in dmpUpdates: will be starting point for next call!
}

//***********************************************************//
/** Get current FIFO buffer size.
 * This value indicates the number of bytes stored in the FIFO buffer. This
 * number is in turn the number of bytes that can be read from the FIFO buffer
 * and it is directly proportional to the number of samples available given the
 * set of sensor data bound to be stored in the FIFO (defined by register 35 and 36).
 * - return: Current FIFO buffer size
 */
unsigned int getFIFOCount(int ChipSelPin)
{
  // FIFO_COUNT should always be read in high-low order (0x72-0x73) in order to
  // guarantee that the most current FIFO Count value is read
  byte fifo_H = SPIread(0x72, ChipSelPin1);
  byte fifo_L = SPIread(0x73, ChipSelPin1);
  unsigned int two_bytes = (fifo_H << 8) | fifo_L;
  return two_bytes;
}

// ############################################################################################## //
// ################################ Main DMP initialize function ################################ //
// ############################################################################################## //
// If you like to know how it works, please read on. Otherwise, just FIRE AND FORGET ;-)

byte dmpInitialize()
{
  // Trigger a full device reset.
  // A small delay of ~50ms may be desirable after triggering a reset.
  SPIwriteBit(0x6B, 7, true, ChipSelPin1); // DEVICE_RESET
  digitalWrite(BLUE_LED_PIN, HIGH); // shows start of DMP inititialize
  delay(30 + 170); // wait after reset + time to see the LED blink

  // Setting the SLEEP bit in the register puts the device into very low power
  // sleep mode. In this mode, only the serial interface and internal registers
  // remain active, allowing for a very low standby current. Clearing this bit
  // puts the device back into normal mode. To save power, the individual standby
  // selections for each of the gyros should be used if any gyro axis is not used
  // by the application.
  // disable sleep mode
  SPIwriteBit(0x6B, 6, false, ChipSelPin1); // SLEEP

  // get MPU hardware revision
  setMemoryBank(0x10, true, true, ChipSelPin1);
  setMemoryStartAddress(0x06, ChipSelPin1);
  digitalWrite(ChipSelPin1,LOW);
  SPI.transfer(0x6F | 0x80); // 0x6F | 0x80 causes a "1" added as MSB to 0x6F to denote reading from reg i.s.o. writing to it
  byte hwRevision = SPI.transfer(0x00);
  digitalWrite(ChipSelPin1,HIGH);
  setMemoryBank(0, false, false, ChipSelPin1);

  // check OTP bank valid
  byte otpValid = SPIreadBit(0x00, 0, ChipSelPin1);

  // get X/Y/Z gyro offsets
  byte xgOffsetTC = SPIreadBits(0x01, 6, 6, ChipSelPin1); // [7] PWR_MODE, [6:1] XG_OFFS_TC, [0] OTP_BNK_VLD
  byte ygOffsetTC = SPIreadBits(0x02, 6, 6, ChipSelPin1); // [7] PWR_MODE, [6:1] YG_OFFS_TC, [0] OTP_BNK_VLD
  byte zgOffsetTC = SPIreadBits(0x03, 6, 6, ChipSelPin1); // [7] PWR_MODE, [6:1] ZG_OFFS_TC, [0] OTP_BNK_VLD

  // load DMP code into memory banks
  if (writeDMPMemory())
  {
    verifyDMPMemory();
        
    digitalWrite(BLUE_LED_PIN, LOW); // shows end of write DMP memory
    delay(200); // time to see the LED blink

    // write DMP configuration
    if (writeDMPConfig())
    {
      verifyDMPConfig();
            
      digitalWrite(BLUE_LED_PIN, HIGH); // shows start of write DMP configuration
      delay(200); // time to see the LED blink

      SPIwriteBits(0x6B, 2, 3, 0x03, ChipSelPin1); // CLKSEL[2:0] = 011 = PLL with Z axis gyroscope reference
      SPIwrite(0x38, 0x12, ChipSelPin1); // INT_ENABLE = 00010010 = FIFO_OFLOW_EN & DMP_INT_EN
      SPIwrite(0x19, 4, ChipSelPin1); // SMPLRT_DIV[7:0] = 4 (ok)
      SPIwriteBits(0x1A, 5, 3, 0x00, ChipSelPin1); // EXT_SYNC_SET[2:0] = 000 = input disabled
      SPIwriteBits(0x1A, 2, 3, 0x03, ChipSelPin1); // DLPF_CFG[2:0] = 011 = accel 44 Hz gyro 42 Hz
      SPIwriteBits(0x1B, 4, 2, 0x03, ChipSelPin1); // FS_SEL[1:0] = 11 = +/- 2000 deg/s
      SPIwriteBits(0x1C, 4, 2, 0x00, ChipSelPin1);

      SPIwrite(0x70, 0x03, ChipSelPin1); // DMP related register
      SPIwrite(0x71, 0x00, ChipSelPin1); // DMP related register

      SPIwriteBit(0x00, 0, false, ChipSelPin1); // [0] OTP_BNK_VLD

      byte update_number = 1;      // holds update number for user information
      unsigned int pos = 0;        // pos        is the current reading position within dmpUpdates; this is the first call; set pos        = 0 only once!
      pos = writeDMPUpdates(pos, update_number); 
      unsigned int pos_verify = 0; // pos_verify is the current reading position within dmpUpdates; this is the first call; set pos_verify = 0 only once!
      pos_verify = verifyDMPUpdates(pos_verify, update_number);

      update_number ++;
      pos = writeDMPUpdates(pos, update_number); 
      pos_verify = verifyDMPUpdates(pos_verify, update_number);

      //SPIwriteBit(0x6A, 6, false, ChipSelPin1); // FIFO_EN = 0 = disable
      SPIwriteBit(0x6A, 2, true, ChipSelPin1); // FIFO_RESET = 1 = reset (ok) only when FIFO_EN = 0
      //SPIwriteBit(0x6A, 6, true, ChipSelPin1); // FIFO_EN = 1 = enable

      // Get current FIFO buffer size.
      // This value indicates the number of bytes stored in the FIFO buffer. This
      // number is in turn the number of bytes that can be read from the FIFO buffer
      // and it is directly proportional to the number of samples available given the
      // set of sensor data bound to be stored in the FIFO (register 35 and 36).
      unsigned int fifoCount = getFIFOCount(ChipSelPin1);
 
      // just after FIFO reset so count probably 0
      SPIreadBytes(0x74, fifoCount, fifoBuffer, ChipSelPin1);

      SPIwrite(0x1F, 2, ChipSelPin1); // MOT_THR[7:0] = 2
      SPIwrite(0x21, 156, ChipSelPin1); // detection threshold for Zero Motion interrupt generation
      SPIwrite(0x20, 80, ChipSelPin1); // duration counter threshold for Motion interrupt generation. The duration counter ticks at 1 kHz, therefore MOT_DUR has a unit of 1 LSB = 1 ms
      SPIwrite(0x22, 0, ChipSelPin1); // duration counter threshold for Zero Motion interrupt generation. The duration counter ticks at 16 Hz, therefore ZRMOT_DUR has a unit of 1 LSB = 64 ms
      SPIwriteBit(0x6A, 2, true, ChipSelPin1); // FIFO_RESET = 1 = reset (ok) only when FIFO_EN = 0
      SPIwriteBit(0x6A, 6, true, ChipSelPin1); // FIFO_EN = 1 = enable
      SPIwriteBit(0x6A, 7, true, ChipSelPin1); // USER_CTRL_DMP_EN
      SPIwriteBit(0x6A, 3, true, ChipSelPin1); // Reset DMP

      update_number ++;
      pos = writeDMPUpdates(pos, update_number); 
      pos_verify = verifyDMPUpdates(pos_verify, update_number);

      update_number ++;
      pos = writeDMPUpdates(pos, update_number); 
      pos_verify = verifyDMPUpdates(pos_verify, update_number);

      update_number ++;
      pos = writeDMPUpdates(pos, update_number); 
      pos_verify = verifyDMPUpdates(pos_verify, update_number);

      while ((fifoCount = getFIFOCount(ChipSelPin1)) < 3);

      byte mpuIntStatus = SPIread(0x3A, ChipSelPin1);

      // Jeff Rowberg's code had a read statement here... I suppose that must be a write statement!
      //DEBUG_PRINTLN(F("Reading final memory update 6/7 (function unknown)..."));
      //for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = pgm_read_byte(&dmpUpdates[pos]);
      //readMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);
      update_number ++;
      pos = writeDMPUpdates(pos, update_number); 
      pos_verify = verifyDMPUpdates(pos_verify, update_number);

      while ((fifoCount = getFIFOCount(ChipSelPin1)) < 3);

      mpuIntStatus = SPIread(0x3A, ChipSelPin1);

      update_number ++;
      pos = writeDMPUpdates(pos, update_number); 
      pos_verify = verifyDMPUpdates(pos_verify, update_number);

      SPIwriteBit(0x6A, 7, false, ChipSelPin1); // USER_CTRL_DMP_EN

      //SPIwriteBit(0x6A, 6, false, ChipSelPin1); // FIFO_EN = 0 = disable
      SPIwriteBit(0x6A, 2, true, ChipSelPin1); // FIFO_RESET = 1 = reset (ok) only when FIFO_EN = 0
      //SPIwriteBit(0x6A, 6, true, ChipSelPin1); // FIFO_EN = 1 = enable
      SPIread(0x3A, ChipSelPin1); // reading the register will clear all INT bits

    }
    else
    {
      return 2; // configuration block loading failed
    }

  }
  else
  {
    return 1; // main binary block loading failed
  }

  digitalWrite(BLUE_LED_PIN, LOW); // shows end of write DMP configuration
  delay(200); // time to see the LED blink

  Serial.println("... Digital Motion Processor (DMP) initializing done.");
  Serial.println(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
  return 0; // success
}